---
title: "Data Wrangling in R Part One"
output: html_notebook
---




(This tutorial is based on work done by Andrew Ba Tran on the learn-r.journalism.com course.)

## Don't forget!

If you open this file, make sure that you run all of the code chunks necessary before you try your own work. In other words, load any libraries and data sets, and make any changes you need to make before you start. One way to do that is to delete all of the output.   This means loading up your tidyverse before doing anything else: 

```{r}
library(tidyverse)


```


### Troubleshooting

The most common errors are: 

* Forgetting to put %>% at the end of the line if you want to continue on. Remember, it means "now do this". Without it, R will see the two lines as entirely separate commands. 
* Having unbalanced quotes and parentheses.
* Not paying attention to the case of variable names and values. In R, "relationship" is an entirely different word than "Relationship" or "RELATIONSHIP".

If you're having trouble go one step at a time. For example, try setting ONE filter before you set two. Or try selecting a few variables before you filter. 

Also, try copying an example you know works and then editing it rather than starting from scratch.

## Explanation of key data fields

The data definitions for each of the fields in this dataset are shown in the documentation to the Murder Accountability Project at https://www.dropbox.com/s/lo6tgo8nnbpqeru/MAPdefinitionsSHR.pdf?dl=1

(A copy is saved in this project.)

I've changed some of the variable names so that they conform to our convention: lower case with an underscore. I've also added some coded fields so that they're easier to query. 


## Load our saved file

You can just read in an R-saved file using the "load" command, without worrying about how R interprets things. It's already been interpreted for you.

Use the str (short for "structure") command to see what's in it:

```{r}
#you can load RData files directly from the Web by using the url() function 
#
load(url("https://cronkitedata.github.io/cronkite-docs/r-stats/murder_data_v2.RData"))
str(murder_data_v2)


```

There is a new type of data element called a factor that is in this data frame. Don't worry about it for now -- you can use it as a character field in the tidyverse. A factor is a variable that is a category -- it only has a limited number of predefined values. You'll see how this works in a minute.

## Verb #1: select()

Remember, the "select" command chooses which columns you want to use for now. If you don't assign the answer to a new data frame, it will just print out on your screen. In this case, there is no new data frame: 

There are lots of ways to identify which columns you want. The simplest are lists of the positions in the data frame (columns 1 through 4, for example), or the names. You can rename the columns while you're selecting them by putting the new name before the old one, connect with an equal sign. If they are more than one word, they must have quotes around them. Use a colon (:) instead of the word "through". 

Use the head() or tail() command to just look at some of the rows. This picks out the first 100 of them. 

```{r}

# You don't have to use the second line -- I added it to make this file smaller. Otherwise it defaults to 10,000 and takes forever. 

murder_data_v2 %>%
select (3,                       #column 3
        agency_id = 4,           #rename column for as agency_id
        agency_name:year) %>%    #pick out the columns agency_name through year
  head(100)   

```

You can also rename as you select: 

### A new verb (sort of): distinct

Instead of "select", you can use the verb "distinct". This verb selects just the unique combinations. Say I want to know what kinds of weapons there are, showing the codes next to the names of the weapons. We can use distinct for that. The "arrange" verb, which we've already seen, orders it by code: 

```{r}

murder_data_v2 %>%
  distinct (weapon_code, weapon) %>%
  arrange (weapon_code)

```

This will come in handy later on when we want to include all guns -- we can just use the codes 1 through 5 rather than typing them all out. 

## filter()

### Filter with one exact condition

Remember, you have to use **TWO** equal signs to set up a filter, not one. Here are a couple of common mistakes and their error messages:  

*#FAIL*

```{r error=TRUE}

murder_data_v2 %>%
filter( relationship = "Wife" )  #only one equal sign

```

Don't get upset when you see an error. In fact, R is showing you what probably went wrong when it says, *do you need '=='?*

```{r error=TRUE}

filter (murder_data_v2, relationship == Husband) #forgetting quotes

```

Whenever you see **_"object ... not found"_** there is usually one of two possible problems: you've fogotten to put quotes around a word, and the system is looking for a **variable** called Husband, instead of the actual letters H-u-s-b-a-n-d. Another common cause for this error is that I've misspelled the variable name. R is case-sensitive in variable names.

```{r}

filter ( murder_data_v2, relationship == "Husband" )

```


### More complex filters

I have 210 rows in which the husband was the victim. But what if I want anyone that suggested domestic violence? Let's first look at what values are in the dataset:

```{r}
murder_data_v2 %>%
  distinct (relationship_code, relationship) %>%
  arrange (relationship_code)

```

There are 29 values in the relationship, and we want anything that suggests domestic violence. Looking at the list, I'd like anything with these codes and values: 

            2	Boyfriend
            3	Brother
            4	Common-law husband			
            5	Common-law wife			
            6	Daughter
            9	Father
            11 Girlfriend			
            12	Homosexual relationship			
            13	Husband			
            14	In-law			
            15	Mother
            17	Other family
            19	Stepdaughter			
            20	Stepfather
            21	Sister			
            22	Stepmother			
            23	Son			
            24	Stepson
            27	Wife			
            28	Ex-husband			
            29	Ex-wife


But it might be easier to EXCLUDE the ones that AREN'T domestic violence: 

            1	Acquaintance
            7	Employee			
            8	Employer
            10 Friend
            16 Neighbor
            18	Other - known to victim
            25	Stranger
            26	Relationship not determined



There are several ways to pick out these items. The first is to make a list with the words you want to include. That would be a long list, something like:


        c("Boyfriend", "Brother", "Common-law husband",
          "Common-law wife", "Daughter", 
          ... and on and on with the list)
          
          
Another way would be to make a list of the codes instead of the words, which is sometimes easier: 

        c(2:6, 9, 11:15, 17, 19:24, 27:29)


Let's try it with the numbers that are codes for the words: 

```{r}

murder_data_v2 %>%
  select (agency_name, 
          year, 
          victim_sex, 
          offend_sex, 
          relationship_code, 
          relationship) %>%
  filter ( relationship_code %in%
            c(2:6, 9, 11:15, 17, 19:24, 27:29)
    )



```

The first thing you see is that there are quite a few errors in this dataset - the relationship has been flipped on its head. The relationship is SUPPOSED to be the victim's relationship to the offender. That means that if the "relationship" says "Husband", and it is a heterosexual marriage, the victim_sex MUST be "Male".  It's not. We'll look at how to tease out these kinds of errors later, and will not worry about it for now. Your


Let's narrow it  down to victims at least 60 years old, using another way to list the relationships:

```{r}
murder_data_v2 %>%
  filter ( relationship %in%
             c ("Common-law wife",
              "Father",
              "Girlfriend",
              "Husband",
              "Mother",
              "Wife",
              "Ex-wife",
              "Boyfriend",
              "Common-law husband",
              "Daughter",
              "Homosexual relationship",
              "Ex-husband" )
           &
             victim_age >= 60
    )


```

Let's save a little piece of this table by putting together our filter with a select

```{r}

murder_extract <-

murder_data_v2 %>%
  select (id:agency_name,
          solved, 
          year, 
          starts_with("victim"),
          starts_with("offend"),
          weapon_code:circumstance) %>%

  filter ( relationship_code %in% c(2:6, 9, 11:15, 17, 19:24, 27:29) &
             victim_age >= 60 )  %>%
    arrange (agency_name, year)


```


Nothing happened! It's because you saved it into a new data frame instead of printing it out. If you want to print it out, just add a code chunk with the name of the new data frame: 


```{r}

murder_extract


```


## The missing wildcard

From what I can tell, filter() has no equivalent to Excel or other languages' wild cards. For example, in most languages, if you type

      my_variable_name like "Unknown%"

You would get back anything that **started** with the word "Unknown". I also don't see a way to turn off case-sensitivity, which can be a real problem when you deal with data that isn't sanitized. It's especially a problem when dealing with proper names and addresses, or any variable composed of free text that someone can make up without a formal code book. 

The Tidyverse comes with a package called "stringr", which handles all of the text (or, in computereze, "string") manipulations. This package treats factors as strings, so you don't have to worry about the underlying data type (or at least I think that's true).

### Dealing with case-sensitivity

To a computer, "Sarah" is different from "SARAH" or "sarah". They'll never match. There are several ways to deal with this in R. The easiest of these is to upper- or lower-case everything in the database before you try to match anything. This is a pain, much like standardizing the convention of naming, but it's worth it if you're doing a lot of queries and can't be sure. The other way is to use what's called "regular expressions", and indicate that it's not case-sensitive. 

If you know what the entire variable contains, the simplest approach is to lowercase the whole thing.  There can still be a problem if there are invisible leading or trailing spaces (which we got rid of in the first step above), but this often works. 

Just be sure to lower-case the original field like this: 

```{r}

murder_extract %>%
  filter(
          str_to_lower(agency_name) ==  "phoenix"
         )

```


### Everything BUT filters

Sometimes it's easier to say what you DON'T want vs. what you DO want. In this case, let's say we only want agencies that are not Phoenix. Put an exclamation mark before your filter. 

Just be a little careful. Mixing "not" with other filters can be confusing. 

```{r}
murder_extract %>%
  filter (! str_to_lower(agency_name) == "phoenix")


```



## Verb 3: Group_by / summarise

Group by is the same as a pivot table. The "groups" are the piles you create, like the fields you dragged into the row or column variable in pivot tables. "Summarize" is the part where you decide which number you want, like the Count, Average, and Sum in the value area of a pivot table. 

The key ones are: 

* n() = count, or the answer to "how many"
* n_distinct(*fieldname*)  = how many unique answers are there? 
* sum(*fieldname*, na.rm=TRUE)

There are many more. Just note that if you do any math, you usually need something at the end to ignore NA values (na.rm=TRUE)

Let's see how this works by checking our data to see how many of the relationships seem wrong. I'd like to see how many "Husbands" are "Female", and how many "Wife" values have "Male" -- those can't be true. Let's take a look: 


```{r}

murder_extract %>%
  filter (relationship %in% c("Wife", "Husband")) %>%
  group_by (relationship, victim_sex, offend_sex) %>%
  summarise (num_cases = n() )


```

In our little extract, there are three erroneous cases of the victim as a Female but the relationship as Husband. This is one way to check your data -- pick out things that can't be true and see how many there are. 

We're not going to worry about this right now, but if you were to publish anything based on this data, you'd want to figure out what's wrong -- is an agency always mis-coding their data? Or is it limited to a certain time period? 

## A new verb: Mutate

The verb Mutate lets you create new variables from old variables. It's often used in a dataset like this with conditions. 

Let's say we didn't want to have to identify all of the different kinds of guns to find gun-related murders. First, let's look at what we have in the dataset: 

```{r}

murder_data_v2 %>%
  group_by (weapon_code, weapon) %>%
  summarise (num_cases = n() ) %>%
  arrange (weapon_code)
  
  

```


The codes 1 through 5 are guns. We want to say, 

      "If the code is 1 through 5, give it a "Yes" for a new variable called is_gun. Otherwise, give it a "No""


Here's how you do that with two new commands: mutate and if_else, creating a new data frame called az_murders

```{r}
az_murders  <-
  murder_data_v2 %>%
  mutate (is_gun = 
              if_else ( weapon_code %in% (1:5) ,  #if this condition is true, just like a filter
                        "Yes",                    #then give it this value
                        "No"  )                    #otherwise give it this value
                
          )  #and don't forget your closing parentheses


```

Now let's see what we have, showing the "Yes" before "No" (desc(is_gun)) and then by descending frequency: 

```{r}
az_murders %>%
  group_by (weapon, is_gun) %>%
  summarise (num_cases = n() ) %>%
  arrange (desc(is_gun), desc(num_cases))


```


## Save your new data frame for later

If you don't want to have to do all of this again, you can save your data frame as an R file, then just read it back in the way we did at the beginning. To do that, you just issue the save command: 

```{r}

save(az_murders, file="az_murders.RData")

```




